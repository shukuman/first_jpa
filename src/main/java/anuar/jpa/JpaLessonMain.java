package anuar.jpa;

import anuar.jpa.entity.Category;
import anuar.jpa.entity.Product;
import anuar.jpa.entity.Specification;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;

import java.util.List;

public class JpaLessonMain {
    public static void main(String[] args) {

        /* Maven - отдельная программа предназначенная для автоматизации
        процесса сборки приложений написанных на Java. Maven позволяет в
        удобной форме описать проект, используемый перечень зависимостей,
        плагинов и так далее. Зависимостью называется внешняя библиотека
        которой нет в стандартной библиотеке предоставляемой JDK. Проект
        может содержать в себе множество зависимостей без которых его работа
        не будет возможна. Зависимости можно подключать вручную и без Maven,
        но это будет довольно длительный процесс который программа Maven и
        автоматизирует. Maven предоставляет центральный репозиторий
        содержащий в себе множество зависимостей которые можно подключить к
        проекту указав их координационные данные (groupId и artifactId).
        Для Maven обязательным является наличие файла pom.xml в корневом
        каталоге проекта, в данном файле описываются координаты проекта
        (groupId и artifactId), параметры, плагины и перечень зависимостей.
        По умолчанию Maven способен обнаруживать и работать с зависимостями
        только своего центрального репозитория находящегося по адресу
        mvnrepository.com, но есть возможность добавить и дополнительные
        источники из которых так же могут подтягиваться зависимости
        (источники могут быть локальными либо удалёнными). Maven состоит из
        ряда жизненных циклов каждый из которых определяет свой перечень
        действий (фаз) производимых с проектом.

        // В стандартной библиотеке JDK доступен модуль для работы с
        // реляционными базами данных под названием JDBC, для работы с ним не
        // нужны устанавливать никаких дополнительных зависимостей кроме
        // драйвера для подключения к базе. При работе есть перечень проблем
        // которые делают его использование не совсем удобным:

        // 1) Все запросы в JDBC пишутся на нативном SQL диалекте используемой
        // базы данных что при переходе на другую базу приведёт к
        // дополнительным накладным расходам на оптимизацию запросов.

        // 2) В JDBC для работы с результатом select запросов используется
        // объект ResultSet который позволяет доставать результирующие данные в
        // виде фрагментов информации (отдельно имя, отдельно возраст и так
        // далее), на практике нам всегда удобнее работать не с частью
        // информации, а с цельным объектом.

        // Java EE (Jakarta EE) - набор спецификаций описывающих модули не
        // входящие в стандартную библиотеку JDK предназначенные для разработки
        // корпоративных приложений (в основном работающих по протоколу HTTP).
        // Одним из модулей Java EE является JPA описывающий взаимодействие с
        // реляционными базами данных по принципу ORM. ORM - схема работы с
        // реляционной базой данных называемая объектно-реляционным
        // сопоставлением позволяющая легко переводить данные из табличного
        // вида к объектам и наоборот. В JPA класс используемый для
        // интерпретации записи определённой таблицы называется сущностью.

        // table humans       -> ORM -> class Human
        // id serial8         -> ORM -> Long id
        // first_name varchar -> ORM -> String firstName
        // last_name varchar  -> ORM -> String lastName
        // birthdate date     -> ORM -> LocalDate birthdate

        // Важно понимать что JPA это всего лишь стандарт описывающий объекты
        // потенциальной библиотеки, сам JPA не представляет собой конкретной
        // библиотеки которую можно установить и поработать с её возможностями.
        // Для работы с возможностями описанными в стандарте JPA необходимо
        // установить в качестве зависимости одну из его реализаций.
        // 1) Hibernate;
        // 2) EclipseLink;
        // 3) ...;

        // Hibernate можно подключить в качестве зависимости через Maven, в
        // центральном репозитории mvnrepository.com нам необходимо найти
        зависимости под названием hibernate-core.
         */

        // Для определения параметров подключения к серверу базы данных в
        // стандарте JPA предусмотрен центральный конфигурационный файл под
        // названием `persistence.xml`. Данный файл должен в обязательном
        // порядке включаться в итоговую сборку (артефакт). В Maven
        // предусмотрены 2 типа файлов попадающих в сборку: исходный код
        // написанный на Java (папка java) и всё остальное (папка resources).

        // Ни один язык программирования не может напрямую взаимодействовать с
        // сервером базы данных без специальной программной прослойки
        // называемой драйвером, цель драйвера принять команду от языка
        // программирования и перенаправить её на выполнение серверу, так же
        // драйвер переводит ответ сервер в формат удобный для использования в
        // языке программирования.

        // Java Application -> PostgreSQL Java Driver -> PostgreSQL
        // C++ Application  -> PostgreSQL C++ Driver  -> PostgreSQL
        // PHP Application  -> PostgreSQL PHP Driver  -> PostgreSQL

        // `EntityManager` - объект предоставляющий методы для произведения
        // различных операций над сущностями (создание, изменение, удаление и
        // выборка). Так же EntityManager можно использовать для выполнения
        // запросов на специальном языке JPQL. Каждая сущность привязывается к
        // внутреннему кэшу объекта EntityManager и после его закрытия (close)
        // становится не актуальной.

        // `*.find(Class<T> clazz, Object id) : T` - возвращает сущность типа T
        // по заданному значению первичного ключа из параметра id, если
        // сущности с заданным первичным ключом не существует результатом
        // будет null.

        // `*.persist(Object entity) : void` - сохраняет переданную сущность в
        // локальный кэш EntityManager с пометкой что она новосозданная.

        // Транзакция - группа запросов отправляемая на выполнение к серверу
        // базы данных по принципу всё или ничего, то есть либо будут выполнены
        // все запросы из отправляемой группы, либо ни один из них. Транзакции
        // предназначены для сохранения главного принципа любой базы данных -
        // это целостность данных. Без использования транзакций EntityManager
        // производит все действия затрагивающие изменения исключительно в
        // своём локальном кэше никак не оповещая об изменениях сервер базы
        // данных. Если мы хотим чтобы локальные изменения отражались на
        // сервере базы данных, эти изменения необходимо производить
        // исключительно в контексте транзакции.

        EntityManagerFactory factory = Persistence.createEntityManagerFactory("main");

        EntityManager manager = factory.createEntityManager();

        // select * from categories where id = 1
        Category category = manager.find(Category.class, 1);

        if (category != null) {
            System.out.println(category.getName());
        } else {
            System.out.println("Категории с заданным 'id' не существует");
        }

        List<Product> products = category.getProducts();
        for (Product product : products) {
            System.out.printf("- %s (%d)\n", product.getName(), product.getPrice());
        }

        Product product = manager.find(Product.class, 4);
        System.out.printf("Категория: %s\n", product.getCategory().getName());
        System.out.printf("Название: %s\n", product.getName());
        System.out.printf("Стоимость: %s\n", product.getPrice());
        
        // Транзакция
        /*try {
            manager.getTransaction().begin();

            //Category category = new Category();
            //category.setName("Мебель");
            //manager.persist(category);

            // Изменение названия категории
            //Category category = manager.find(Category.class, 3);
            //category.setName("New name");

            // Удаление категории
            Category category = manager.find(Category.class, 3);
            manager.remove(category);

            manager.getTransaction().commit();

        } catch (Exception e) {
            manager.getTransaction().rollback();
            throw new RuntimeException(e);
        }

        manager.close();
        factory.close();
         */
    }
}